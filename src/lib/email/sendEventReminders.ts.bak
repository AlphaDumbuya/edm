import prisma from '@/lib/db/prisma';
import { getEventReminderEmailHtml, getEventReminderEmailText } from '@/emails/event-reminder-template';
import nodemailer from 'nodemaile      // Find events that need reminders using a raw SQL query for precise datetime handling
      const upcomingEvents = await prisma.$queryRaw<(Event & { eventRegistrations: EventRegistration[] })[]>`
        WITH event_times AS (
          SELECT 
            e.*,
            (e.date::date + e.time::time)::timestamp as event_datetime
          FROM "Event" e
          WHERE e.id NOT IN (
            SELECT "eventId" FROM "SentReminder"
            WHERE "type" = ${window.type}
            AND "createdAt" >= ${todayStart}
          )
        )
        SELECT e.*, er."id" as "regId", er."name", er."email", er."eventId"
        FROM event_times e
        LEFT JOIN "EventRegistration" er ON e."id" = er."eventId"
        WHERE 
          e.event_datetime >= ${eventTimeStart}::timestamp
          AND e.event_datetime <= ${eventTimeEnd}::timestamp
      `;
      
      // Group registrations by event
      const events: { [key: string]: Event & { eventRegistrations: EventRegistration[] } } = {};
      for (const row of upcomingEvents) {
        const { regId, name, email, eventId, ...event } = row;
        if (!events[event.id]) {
          events[event.id] = { ...event, eventRegistrations: [] };
        }
        if (regId) {
          events[event.id].eventRegistrations.push({
            id: regId,
            name,
            email,
            eventId,
            createdAt: new Date(),
            updatedAt: new Date()
          });
        }
      }

      const eventsArray = Object.values(events);
      console.log(`Found ${eventsArray.length} events to check for ${window.type} reminders`);

      // Process each eventat, addHours, addMinutes } from 'date-fns';
import { Event, EventRegistration, Prisma } from '@prisma/client';

type ReminderType = '24h' | '1h' | '30m';

interface ReminderConfig {
  type: ReminderType;
  minutesBeforeEvent: number;
  subject: (eventTitle: string) => string;
}

const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: Number(process.env.SMTP_PORT),
  secure: process.env.SMTP_SECURE === 'true',
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASSWORD,
  },
});

type EventWithRelations = Event & {
  eventRegistrations: EventRegistration[];
  sentReminders: {
    id: string;
    eventId: string;
    type: string;
    createdAt: Date;
    updatedAt: Date;
  }[];
};

const REMINDER_CONFIGS: ReminderConfig[] = [
  {
    type: '24h',
    minutesBeforeEvent: 24 * 60,
    subject: (eventTitle) => `Reminder: ${eventTitle} starts in 24 hours`,
  },
  {
    type: '1h',
    minutesBeforeEvent: 60,
    subject: (eventTitle) => `Reminder: ${eventTitle} starts in 1 hour`,
  },
  {
    type: '30m',
    minutesBeforeEvent: 30,
    subject: (eventTitle) => `Reminder: ${eventTitle} starts in 30 minutes`,
  },
];

async function sendReminderEmail(
  registration: EventRegistration,
  event: Event,
  reminderType: ReminderType,
  subject: string
) {
  const timeText = reminderType === '24h' ? '24 hours' : 
                   reminderType === '1h' ? '1 hour' : 
                   '30 minutes';

  // Convert null to undefined for the online link
  const onlineLink = event.onlineLink ?? undefined;

  // Calculate minutes until event starts
  const eventDateTime = new Date(`${event.date}T${event.time}`);
  const minutesUntilEvent = Math.floor((eventDateTime.getTime() - new Date().getTime()) / (1000 * 60));

  // Include link if it's a virtual event and either:
  // 1. This is the 30-minute reminder, or
  // 2. The event starts in less than 30 minutes
  const shouldIncludeLink = event.isVirtual && (
    reminderType === '30m' || 
    (minutesUntilEvent <= 30 && minutesUntilEvent >= 0)
  );

  const html = getEventReminderEmailHtml({
    name: registration.name,
    eventTitle: event.title,
    eventDate: format(new Date(event.date), 'MMMM do, yyyy'),
    eventTime: event.time,
    eventLocation: event.location,
    isVirtual: event.isVirtual,
    onlineLink: shouldIncludeLink ? onlineLink : undefined,
    timeUntilEvent: timeText,
  });

  const text = getEventReminderEmailText({
    name: registration.name,
    eventTitle: event.title,
    eventDate: format(new Date(event.date), 'MMMM do, yyyy'),
    eventTime: event.time,
    eventLocation: event.location,
    isVirtual: event.isVirtual,
    onlineLink: shouldIncludeLink ? onlineLink : undefined,
    timeUntilEvent: timeText,
  });

  try {
    const finalSubject = shouldIncludeLink ? `${subject}${event.isVirtual ? ' - Join Link Included' : ''}` : subject;
    await transporter.sendMail({
      from: `"${process.env.EMAIL_FROM_NAME}" <${process.env.SMTP_USER}>`,
      to: registration.email,
      subject: finalSubject,
      html,
      text,
    });
    console.log(`Sent ${reminderType} reminder email to ${registration.email} for event: ${event.title}`);
  } catch (error) {
    console.error(`Failed to send ${reminderType} reminder email to ${registration.email}:`, error);
  }
}

export async function sendEventReminders() {
  const now = new Date();
  console.log('Running event reminders at:', now.toISOString());

  try {
    // Record that we're checking for reminders
    await prisma.auditLog.create({
      data: {
        action: 'CHECK_REMINDERS',
        entityType: 'Event',
        details: { timestamp: now.toISOString() }
      }
    });
    
    // Calculate reminder windows by looking ahead
    const windows = REMINDER_CONFIGS.map(config => {
      // Calculate when events should start based on the current time and reminder window
      const targetEventTime = addMinutes(now, config.minutesBeforeEvent);
      
      // Create a wider window for finding events (±15 minutes)
      const window = {
        ...config,
        startTime: addMinutes(targetEventTime, -15),  // Look 15 minutes earlier
        endTime: addMinutes(targetEventTime, 15),    // Look 15 minutes later
      };
      
      console.log(`Calculating ${config.type} reminder window:`, {
        now: format(now, 'yyyy-MM-dd HH:mm:ss'),
        targetEventTime: format(targetEventTime, 'yyyy-MM-dd HH:mm:ss'),
        windowStart: format(window.startTime, 'yyyy-MM-dd HH:mm:ss'),
        windowEnd: format(window.endTime, 'yyyy-MM-dd HH:mm:ss'),
        minutesBeforeEvent: config.minutesBeforeEvent
      });
      
      return window;
    });

    // Find events for each reminder window
    for (const window of windows) {
      console.log(`Processing ${window.type} reminders`);
      
      // Calculate the time range we're looking for events in
      const eventTimeStart = window.startTime;
      const eventTimeEnd = window.endTime;
      
      console.log('Time window for events:', {
        type: window.type,
        startTime: format(eventTimeStart, 'yyyy-MM-dd HH:mm:ss'),
        endTime: format(eventTimeEnd, 'yyyy-MM-dd HH:mm:ss')
      });

      // Get existing reminders for this time window and type
      const todayStart = new Date(new Date().setHours(0, 0, 0, 0));
      const existingReminders = await prisma.$queryRaw<{ eventId: string }[]>`
        SELECT "eventId" 
        FROM "SentReminder" 
        WHERE "type" = ${window.type}
        AND "createdAt" >= ${todayStart}
      `;

      const eventIdsWithReminders = new Set(existingReminders.map(r => r.eventId));

      // Find events that need reminders
      // For each event, we'll calculate its exact scheduled time using date + time fields
      const upcomingEvents = await prisma.event.findMany({
        where: {
          AND: [
            // Get events without reminders sent today
            { id: { notIn: Array.from(eventIdsWithReminders) as string[] } },
            
            // Use a date range that covers potential events
            {
              date: {
                gte: format(eventTimeStart, 'yyyy-MM-dd'),
                lte: format(eventTimeEnd, 'yyyy-MM-dd')
              }
            }
          ]
        },
        include: {
          eventRegistrations: true
        }
      });

      console.log(`Found ${upcomingEvents.length} total events for dates ${format(eventTimeStart, 'yyyy-MM-dd')} to ${format(eventTimeEnd, 'yyyy-MM-dd')}`);
      
      // Filter events that should get reminders now
      const eventsNeedingReminders = upcomingEvents.filter(event => {
        // Convert event time and date to a full Date object
        const [eventHour, eventMinute] = event.time.split(':').map(Number);
        const eventDateTime = new Date(event.date);
        eventDateTime.setHours(eventHour, eventMinute, 0, 0);
        
        // Calculate target event time (when the event should start)
        const targetEventTime = addMinutes(now, window.minutesBeforeEvent);
        
        // Event should be within ±15 minutes of target time
        const diffInMinutes = Math.abs((eventDateTime.getTime() - targetEventTime.getTime()) / (60 * 1000));
        const timeMatches = diffInMinutes <= 15;

        console.log(`Event time check for ${event.title}:`, {
          eventDateTime: format(eventDateTime, 'yyyy-MM-dd HH:mm:ss'),
          targetEventTime: format(targetEventTime, 'yyyy-MM-dd HH:mm:ss'),
          diffInMinutes,
          timeMatches,
          registrations: event.eventRegistrations.length
        });

        return timeMatches;
      });

      // Log each found event's details
      eventsNeedingReminders.forEach(event => {
        console.log('Found event needing reminders:', {
          title: event.title,
          date: format(event.date, 'yyyy-MM-dd'),
          time: event.time,
          isVirtual: event.isVirtual,
          registrations: event.eventRegistrations.length
        });
      });

      console.log(`Found ${eventsNeedingReminders.length} events needing ${window.type} reminders`);

      // Send reminders for each event
      for (const event of eventsNeedingReminders) {
        console.log(`Processing ${window.type} reminders for event: ${event.title}`);

        try {
          // Create a new reminder record first
          await prisma.$executeRaw`
            INSERT INTO "SentReminder" ("id", "eventId", "type", "createdAt", "updatedAt")
            SELECT gen_random_uuid(), ${event.id}, ${window.type}, NOW(), NOW()
            WHERE NOT EXISTS (
              SELECT 1 FROM "SentReminder"
              WHERE "eventId" = ${event.id}
              AND "type" = ${window.type}
              AND "createdAt" >= ${todayStart}
            )
          `;

          // Then send emails to all registrants
          for (const registration of event.eventRegistrations) {
            await sendReminderEmail(
              registration,
              event,
              window.type,
              window.subject(event.title)
            );
          }
        } catch (error) {
          console.error(`Failed to process reminders for event ${event.title}:`, error);
        }
      }
    }
  } catch (error) {
    console.error('Error in sendEventReminders:', error);
  }

  console.log('Finished checking for event reminders');
}
